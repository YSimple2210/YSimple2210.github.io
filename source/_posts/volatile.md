---
title: volatile
date: 2019-12-09 14:41:42
tags: ['多线程','线程安全']
categories: -Java
---

# 1.volatile介绍

简介：volatile是Java虚拟机提供的<font color="red">`轻量级`</font>的同步机制。

# 2.volatile特性

>   1.保证可见性
>
>   2.禁止指令重排
>
>   3.<font color="red">不保证原子性</font>

## 2.1 JMM

在介绍volatile的3特性之前。我们先说一下JMM。

### 2.1.1 什么是JMM？

简介：JMM是（Java内存模型Java Memory Model）本身是一种抽象的概念，并不真实存在，它描述的是一组规范或者规则。

由于JVM运行程序的实体是线程,而每个线程创建时JVM都会为其创建一个<font color="red">工作内存</font>(有些地方成为栈空间),

工作内存是每个线程的私有数据区域, 而Java内存模型中规定所有变量都存储在主内存,

主内存是共享内存区域,所有线程都可访问,<font color="red">但线程对变量的操作(读取赋值等)必须在工作内存中进行,首先要将变量从主内存拷贝到自己的工作空间,然后对变量进行操作,操作完成再将变量写回主内存</font>,不能直接操作主内存中的变量,各个线程中的工作内存储存着主内存中的变量副本拷贝,

因此不同的线程无法访问对方的工作内存,此案成间的通讯(传值) 必须通过主内存来完成,其简要访问过程如下图:

<img src="volatile\jmm.png" style="zoom:80%;" />

### 2.1.2 JMM 保证线程安全的特性

>   -   保证可见性
>   -   保证原子性
>   -   禁止指令重排





## 2.2 可见性

各个线程对主内存中共享变量的操作都是各自的线程拷贝到各自的工作内存中，操作后再写回主内存中。

>   存在问题：线程A修改了共享变量X的值（在自己的线程中进行修改）但是还未写回到主内存中，这时另外一个线程B又对内存中的一个共享变量X进行操作,但此时A线程工作内存中的共享变量X对线程B来说是<font color="red">不可见</font>的,这种<font color="red">工作内存与主内存</font>**同步延迟现象**造成了可见性的问题

## 2.3 原子性

<img src="volatile\volatileNoSafe.png" style="zoom:80%;" />

volatile 不保证其原子性。保证原子性需加锁或者CAS等

## 2.4 有序性(禁止指令重排)

计算机在执行程序时,为了提高性能，编译器和处理器尝尝会做指令重排,一般分为以下3种

<img src="volatile\sort.png">

单线程环境里面确保程序最终执行结果和代码顺序执行结果一直。

处理器在进行重新排序是必须考虑指令之间的<font color="red">数据依赖性</font>

多线程环境中线程交替执行,由于编译器优化重排的存在，两个线程适中的变量能否保持一致性是无法预料的。